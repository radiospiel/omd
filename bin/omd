#!/usr/bin/env ruby

require "bundler/inline"

# rubocop:disable Layout/MultilineMethodCallIndentation
# rubocop:disable Style/GuardClause
gemfile do
  source "https://rubygems.org"
  gem "rb-fsevent", require: false
  gem "simple-cli", require: false
end

require "simple-cli"
require "fileutils"
require "benchmark"
require "tmpdir"
require "open3"
require "digest"
require "pstore"

module OMD
end

module OMD::CLI
  include ::Simple::CLI

  # Watch src directory, and rebuild into dest directory
  def watch(src, dest, clean: false, display: true)
    # -- check src and dest paths ---------------------------------------------

    raise "#{src}: missing or not a file" unless File.exist?(src) && File.file?(src)
    raise "#{dest}: must be a directory"  if File.exist?(dest) && !File.directory?(dest)

    src = File.expand_path(src)
    dest = File.expand_path(dest)
    FileUtils.rm_rf(dest) if clean
    FileUtils.mkdir_p(dest)

    # -- process once (so that we are up to date)

    dest = File.join dest, File.basename(src)
    OMD.process(src, dest)
    system "open", "-a", "Marked 2", dest if display

    # -- watch directories, and rebuild on changes ----------------------------

    require "rb-fsevent"
    fsevent = FSEvent.new
    fsevent.watch [__dir__, File.dirname(src)], latency: 0.1 do |dirs, event_meta|
      next unless detected_change?(dirs, event_meta, src_dir: File.dirname(src))

      OMD.process(src, dest)
    end
    fsevent.run
  end

  private

  def detected_change?(dirs, _event_meta, src_dir:)
    logger.debug "Detected change in", dirs.join(",")

    if dirs.any? { |dir| dir.start_with?(__dir__) }
      logger.info "reloading", __FILE__
      load __FILE__
      return true
    end

    if dirs.any? { |dir| dir.start_with?(src_dir) }
      return true
    end
  end
end

# -- helpers ------------------------------------------------------------------

def File.write(path, body)
  File.open(path, "w") do |io|
    io.write(body)
  end
end

module OMD
  extend self

  def logger
    OMD::CLI.logger
  end

  class Cache
    def self.reset!
      @source_version = nil
    end

    def self.source_version
      @source_version ||= Digest::MD5.hexdigest(File.read(__FILE__))
    end

    reset!

    def self.key(*parts)
      Digest::MD5.hexdigest(source_version + ":" + parts.join(","))
    end

    def initialize(dir)
      @store = PStore.new(File.join(dir, "omd.pstore"))
      @store.ultra_safe = true
    end

    def cached(*keys)
      key = Cache.key(*keys)

      @store.transaction do
        @store[key] ||= yield
      end
    end
  end

  class Writer
    def self.open(path)
      tmp_name = "#{path}.#{$$}"
      writer = new tmp_name
      yield writer
      File.rename(tmp_name, path)
    ensure
      if writer
        writer.close
      end
    end

    def initialize(path)
      @dir = File.dirname(path)
      @fd = File.open path, "w"
      @changes = []
      @cache = Cache.new(@dir)
    end

    def close
      apply_changes

      @fd.close
      @fd = nil
    end

    def transaction(*args)
      apply_changes

      changes = @cache.cached(*args) do
        yield
        @changes
      end
      @changes = changes
      apply_changes
    end

    # -- basic ops ------------------------------------------------------------
    # basic ops are caught in the transaction.

    def line(line)
      @changes << [:line, line]
    end

    def code_block(body, lang: nil)
      @changes << [:code_block, body, lang]
    end

    # -- secondary ops --------------------------------------------------------
    # secondary ops are built off basic ops

    def copy_file(path)
      digest = Digest::MD5.hexdigest File.read(path)
      dest_file = File.join(@dir, "#{digest}#{File.extname(path)}")
      FileUtils.cp(path, dest_file)
      File.basename(dest_file)
    end

    def image(src, alt: nil)
      dest_path = copy_file(src)
      line "![#{alt}](./#{dest_path})"
    end

    def error(body)
      code_block body, lang: "error"
    end

    def table(csv, separator:)
      csv = "|" + csv.gsub("\n", "|\n|") + "|"
      csv = csv.gsub(separator, " | ")

      # | Tables   |      Are      |  Cool |
      # |----------|:-------------:|------:|
      #
      # | col 1 is |  left-aligned | $1600 |
      # | col 2 is |    centered   |   $12 |
      # | col 3 is | right-aligned |    $1 |

      header, rest = csv.split("\n", 2)
      line(header)
      sep = header.gsub(/./) { |ch| ch == "|" ? "|" : "-" }
      line(sep)

      line(rest)
    end

    private

    # this method is used for transaction.
    def apply_changes
      @changes.each do |change, *args|
        case change
        when :line
          line, = *args
          @fd.puts line
        when :code_block
          body, lang = *args
          @fd.puts <<~MD
            ```#{lang}
            #{body.chomp}
            ```
          MD
        end
      end
      @changes = []
    end
  end

  # Process one or more input files, put results into dest
  def process(src, dest)
    logger.debug "processing #{src}"

    processing_time = nil

    Writer.open(dest) do |writer|
      processing_time = Benchmark.realtime do
        input = File.open src

        # read file line by line. Extract and yield omd blocks
        while (line = input.gets)
          unless line =~ /^```{\s*(.*)\s*}\s*$/
            writer.line(line)
            next
          end

          omd_args = Regexp.last_match(1)
          # read until end of omd block
          code_block = []
          while (line = input.gets)
            break if line.start_with?("```")

            code_block << line
          end

          code_block = code_block.join("")
          code_block = unintend(code_block)

          print_code_block(omd_args, code_block, writer: writer)
          process_code_block(omd_args, code_block, writer: writer)
        end
      end
    end

    logger.info "generated #{dest} from #{src}: #{"%.3f secs" % processing_time}"
  end

  def unintend(code_block)
    code_block = code_block
      .split("\n")

    number_of_leading_spaces = code_block
      .map { |line| line =~ /^( +)/ && $1 }
      .compact
      .map(&:length)
      .min

    code_block
      .map { |line| line =~ /^ / ? line[number_of_leading_spaces..-1] : line }
      .map { |line| "#{line}\n" }.join
  end

  class ShellError < RuntimeError; end

  module H
    extend self

    def sh!(cmd)
      OMD.logger.debug "Running #{cmd}"
      stdout_str, stderr_str, status = Open3.capture3(cmd)
      return stdout_str if status.exitstatus == 0

      raise ShellError, stderr_str
    end
  end

  module Processors
    extend self

    def comment(intro, code_block, writer:); end

    def dot(_intro, code_block, writer:)
      File.write("omd.dot", code_block)

      H.sh! "dot -Tpng -Gsize=16,16\! -Gdpi=72  -o dot.png omd.dot"

      writer.image "dot.png", alt: "dot"
    end

    def cc(_intro, code_block, writer:)
      File.write("omd.cc", code_block)

      H.sh! "cc -Wall omd.cc"

      success = H.sh! "./a.out 10"
      writer.code_block success
    end

    def sql(_intro, code_block, writer:)
      File.write("omd.sql", code_block)

      success = H.sh! "psql -F'\t' --no-align -f omd.sql"
      writer.table(success, separator: "\t")
    end
  end

  def print_code_block(intro, code_block, writer:)
    return if intro =~ /^@/
    return if intro =~ /^comment/

    lang = $1 if intro =~ /^@?(\S+)/

    code_block = code_block.gsub(/^@[^\n]*\n/, "")
                            .gsub(/^\n/, "")
    writer.code_block(code_block, lang: lang)
  end

  def process_code_block(intro, code_block, writer:)
    lang = $1 if intro =~ /^@?(\S+)/
    if !lang || !Processors.respond_to?(lang)
      writer.error "omd: Unsupported omd processor #{intro.inspect}"
      return
    end

    writer.transaction lang, code_block do
      logger.warn "intro", intro

      Dir.mktmpdir do |tmpdir|
        Dir.chdir tmpdir do
          code_block = code_block.gsub(/^@\s*/, "")
          Processors.send lang, lang, code_block, writer: writer
        rescue ShellError
          writer.error($!.to_s)
        end
      end
    end
  end
end

unless $loaded
  $loaded = true
  OMD::CLI.run!(*ARGV)
end
