#!/usr/bin/env ruby

require "bundler/inline"

# rubocop:disable Layout/MultilineMethodCallIndentation
# rubocop:disable Style/GuardClause
# rubocop:disable Style/WhileUntilModifier
# rubocop:disable Style/ParallelAssignment

gemfile do
  source "https://rubygems.org"
  gem "rb-fsevent", require: false
  gem "simple-cli", "~> 0.3.13", require: false
  gem "sqlite3", require: false
end

require "simple-cli"
require "fileutils"
require "benchmark"
require "tmpdir"
require "open3"
require "digest"
require "pstore"

class File
  def self.path_relative_to(path, dir)
    if path.start_with?("#{dir}/")
      return path[dir.length+1 .. -1]
    end
  end

  def self.shortpath(path)
    if (shortpath = path_relative_to(path, Dir.getwd))
      shortpath
    elsif (shortpath = path_relative_to(path, ENV["HOME"]))
      "~/" + shortpath
    else
      path
    end
  end
end

module OMD
  extend self

  def logger
    Simple::CLI.logger
  end
end

module OMD::CLI
  include ::Simple::CLI

  # Process src file, and process into a destination file
  #
  # Flags:
  #
  #   --display           Open the "Marked 2" markdown preview
  #   --clean             Clear cache before running
  #
  # Example:
  #
  # To process "doc/README.omd" (generating "doc/README.md"), using
  # cached results from previous runs:
  #
  #     omd process doc/README.omd
  #
  # To process all files in the "doc" directory, ignoring previously
  # cached results, and open the "Marked 2" markdown viewer:
  #
  #     omd process doc --clean --display
  #
  def process(src = ".", clean: false, display: false)
    file_to_display = nil

    source_files_newest_first(src).each do |path|
      dest = OMD.process(src, clean: clean)
      file_to_display ||= dest
    end

    if display && file_to_display
      system "open", "-a", "Marked 2", file_to_display
    end
  end

  # Watches one or more source files, rebuilding results whenever sources change
  #
  # Flags:
  #
  #   --display           Open the "Marked 2" markdown preview
  #   --clean             Clear cache before processing
  #
  # Example:
  #
  # To process the doc/README.omd file (generating doc/README.md) run:
  #
  #     omd watch doc/README.omd
  #
  # This will use cached results from previous runs. To ignore everything
  # in the cache, use the --clean flag, like so:
  #
  #     omd watch doc/README.omd --clean --display
  #
  # To watch an entire directory run
  #
  #     omd watch path/to/dir
  #
  def watch(src, clean: false, display: false)
    # process once (so that we are up to date)
    process src, clean: false, display: display

    # start watching
    require "rb-fsevent"
    fsevent = FSEvent.new

    src_dir = File.directory?(src) ? src : File.dirname(src)

    fsevent.watch [__dir__, src_dir], latency: 0.1 do |changed_dirs, event_meta|
      logger.debug "Detected change in " +
        changed_dirs.uniq.map { |p| File.shortpath(p) }.join(", ")

      # We are watching omd's source dir (in __dir__): if there is a change
      # here we reload the script. This helps during development, and otherwise
      # doesn't hurt (since omd's installation target directory, typically
      # /usr/local/bin, will rarely see changes.
      if changed_dirs.any? { |dir| dir.start_with?(__dir__) }
        logger.info "#{File.shortpath(__FILE__)}: reloading omd source file"
        load __FILE__
        next
      end

      # Otherwise the change must have happened inside the src directory.
      # We are going to reprocess the most recently changed one.
      changed_file = source_files_newest_first(src).first
      process(changed_file) if changed_file
    end
    fsevent.run
  end

  private

  def source_files_newest_first(src)
    if File.directory?(src)
      paths = Dir.glob("#{src}/*.omd")
      paths = paths.sort_by { |path| -File.stat(path).mtime.to_i }
    elsif File.file?(src)
      [src]
    else
      raise "#{src}: must be a file or a directory."
    end
  end
end

# -- helpers ------------------------------------------------------------------

def File.write(path, body = nil, permissions: nil, &block)
  if block
    body = [body, yield].compact.join("\n")
  end

  File.open(path, "w") do |io|
    io.write(body)
  end

  File.chmod permissions, path if permissions

  path
end

module OMD
  module SourceVersion
    extend self

    def reset!
      OMD.logger.debug "reset source_version"
      @source_version = nil
    end

    reset!

    def reloaded?
      reloaded = @previous_source_version != OMD::SourceVersion.source_version
      @previous_source_version = OMD::SourceVersion.source_version
      reloaded
    end

    def source_version
      return @source_version if @source_version

      @source_version = Digest::MD5.hexdigest(File.read(__FILE__))
      OMD.logger.debug "source_version", @source_version
      @source_version
    end
  end
end

module OMD
  class Cache
    def self.key(*parts)
      Digest::MD5.hexdigest(OMD::SourceVersion.source_version + ":" + parts.join(","))
    end

    def initialize(dir)
      @store = PStore.new(File.join(dir, ".omd.pstore"))
      @store.ultra_safe = true
    end

    def cached(*keys)
      key = Cache.key(*keys)

      @store.transaction do
        @store[key] ||= yield
      end
    end
  end

  def dest_data_dir(dest)
    dirname, basename = File.dirname(dest), File.basename(dest)
    File.join(dirname, "#{basename}.data")
  end

  class Writer
    def self.open(path)
      # tmp_name = "#{path}.#{$$}"
      writer = new(OMD.dest_data_dir(path), path)
      yield writer
      # File.rename(tmp_name, path)
    ensure
      if writer
        writer.close
      end
    end

    def initialize(dir, path)
      @fd = File.open(path, "w")
      @dir = dir
      @changes = []
      @cache = Cache.new(@dir)
    end

    def close
      apply_changes

      @fd.close
      @fd = nil
    end

    def transaction(*args)
      apply_changes

      begin
        changes = @cache.cached(*args) do
          yield
          @changes
        end
        @changes = changes
      rescue IncompleteTransaction
        @changes = []
        yield
        @changes = changes
      end

      apply_changes
    end

    # -- basic ops ------------------------------------------------------------
    # basic ops are caught in the transaction.

    def line(line)
      @changes << [:line, line]
    end

    def code_block(body, lang: nil)
      @changes << [:code_block, body, lang]
    end

    # -- secondary ops --------------------------------------------------------
    # secondary ops are built off basic ops

    class IncompleteTransaction < RuntimeError; end

    def copy_file(path)
      unless File.exist?(path)
        raise IncompleteTransaction, "copy_file: missing file #{path}"
      end

      digest = Digest::MD5.hexdigest File.read(path)
      dest_file = File.join(@dir, "#{digest}#{File.extname(path)}")
      FileUtils.mkdir_p @dir
      FileUtils.cp(path, dest_file)
      OMD.logger.debug "copy_file #{path} -> #{dest_file}"

      File.join(File.basename(@dir), File.basename(dest_file))
    end

    def image(src, alt: nil)
      OMD.logger.debug "image #{src.inspect}"

      dest_path = copy_file(src)
      line "![#{alt}](./#{dest_path})"
    end

    def error(body)
      code_block body, lang: "error"
    end

    def table(csv, separator:)
      csv.chomp!
      csv = "|" + csv.gsub("\n", "|\n|") + "|"
      csv = csv.gsub(separator, " | ")

      # | Tables   |      Are      |  Cool |
      # |----------|:-------------:|------:|
      #
      # | col 1 is |  left-aligned | $1600 |
      # | col 2 is |    centered   |   $12 |
      # | col 3 is | right-aligned |    $1 |

      header, rest = csv.split("\n", 2)
      line(header)
      sep = header.gsub(/./) { |ch| ch == "|" ? "|" : "-" }
      line(sep)

      line(rest)
    end

    private

    # this method is used for transaction.
    def apply_changes
      @changes.each do |change, *args|
        case change
        when :line
          line, = *args
          @fd.puts line
        when :code_block
          body, lang = *args
          @fd.puts <<~MD
            ```#{lang}
            #{body.chomp}
            ```
          MD
        end
      end
      @changes = []
    end
  end

  class FileReader
    def self.open(file)
      new file
    end

    def initialize(file)
      @file = file
      @fd = File.open(file)
      @line = 0
    end

    def location
      @shortpath ||= File.shortpath(@file)
      "#{@shortpath}:#{@line}"
    end

    def gets
      @line += 1
      @fd.gets
    end
  end

  private

  def check_paths(src)
    dest = src.gsub(/\.[^\.]*$/, "") + ".md"

    raise "#{src} and #{dest} files must differ" unless src != dest
    raise "#{src}: missing or not a file" unless File.exist?(src) && File.file?(src)
    raise "#{dest}: cannot be a directory" if File.exist?(dest) && File.directory?(dest)

    src = File.expand_path(src)
    dest = File.expand_path(dest)

    raise "input and output file must be in the same directory" if File.dirname(src) != File.dirname(dest)

    [src, dest]
  end

  def prepare_destination(dest, clean:)
    FileUtils.rm_rf(dest_data_dir(dest)) if clean
    FileUtils.mkdir_p(dest_data_dir(dest))
  end

  public

  # Process one or more input files, put results into dest
  def process(src, clean:)
    src, dest = check_paths(src)
    return if File.exist?(dest) && File.mtime(src) < File.mtime(dest) && !OMD::SourceVersion.reloaded?

    prepare_destination(dest, clean: clean)

    processing_time = nil

    Writer.open(dest) do |writer|
      processing_time = Benchmark.realtime do
        file_reader = FileReader.open src

        # read file line by line. Extract and yield omd blocks.
        #
        # omd blocks begin with three backticks, followed by omd arguments
        # in curly braces.
        while (line = file_reader.gets)
          unless line =~ /^```{\s*(.*)\s*}\s*$/
            writer.line(line)
            next
          end

          # extract omd arguments.
          omd_args = Regexp.last_match(1)

          # read until end of omd block. The lines read we'll read here
          # will form the input of the omd processor.
          code_block = []
          while (line = file_reader.gets)
            break if line.start_with?("```")

            code_block << line
          end

          code_block = code_block.join("")
          code_block = unintend(code_block)

          # print code block. If the code block
          print_code_block(omd_args, code_block, writer: writer)

          writer.transaction(omd_args, code_block) do
            process_code_block(file_reader, omd_args, code_block, writer: writer)
          end
        end
      end
    end

    logger.info "#{File.shortpath src}: generated #{File.shortpath dest}: #{"%.3f secs" % processing_time}"
  rescue
    logger.error "#{File.shortpath src}: could not generate #{File.shortpath dest}"
    raise
  end

  def shortpath(x)
    {}.extend(OMD::CLI).send(:shortpath, x)
  end

  def unintend(code_block)
    code_block = code_block
      .split("\n")

    number_of_leading_spaces = code_block
      .reject { |line| line =~ /^\s*$/ }
      .map { |line| line =~ /^( *)/ && $1 }
      .compact
      .map(&:length)
      .min

    code_block
      .map { |line| line =~ /^ / ? line[number_of_leading_spaces..-1] : line }
      .map { |line| "#{line}\n" }.join
  end

  class ShellError < RuntimeError; end

  module H
    extend self

    def sh(cmd)
      sh! cmd, raise_on_error: false
    end

    def which(binary)
      sh!("type -p #{binary}", quiet: true)
    rescue ShellError
      nil
    end

    def which!(binary, hint = nil)
      return if which(binary)

      STDERR.puts "This omd file requires a #{binary} installation."

      if hint
        STDERR.puts <<~MSG
        Try to run

        #{installation}

        to install it on your local machine.
        MSG
      end

      exit 1
    end

    def sh!(cmd, raise_on_error: true, quiet: false)
      OMD.logger.debug "Running '#{cmd}'" unless quiet
      stdout_str, stderr_str, status = Open3.capture3(cmd)

      return stdout_str if status.exitstatus == 0
      return stdout_str if !raise_on_error

      OMD.logger.warn "Running #{cmd} failed w/exit status #{status.exitstatus}"
      OMD.logger.info stderr_str

      raise ShellError, stderr_str if raise_on_error
    end
  end

  module Processors
    extend self

    def comment(intro, code_block, writer:); end

    def dot(filters, code_block, writer:)
      File.write("omd.dot", code_block)

      H.sh! "dot -Tpng -Gsize=16,16\! -Gdpi=72  -o dot.png omd.dot"

      writer.image "dot.png", alt: "dot"
    end

    def ruby(filters, code_block, writer:)
      gemfile = ENV["BUNDLE_GEMFILE"]

      if gemfile
        ENV["BUNDLE_GEMFILE"] = nil
      end

      File.write("omd.rb", code_block, permissions: 0o755)

      result = H.sh! "ruby ./omd.rb"
      writer.code_block result, lang: "ruby"
    ensure
      ENV["BUNDLE_GEMFILE"] = nil if gemfile
    end

    def bob(filters, code_block, writer:)
      File.write("omd.bob", code_block)
      result = H.sh! "svgbob omd.bob -o bob.svg"
      writer.image "bob.svg", alt: "svgbob"
    end

    def mermaid(filters, code_block, writer:)
      H.which! "mmdc", "brew install mermaid-cli"

      File.write("omd.mmd", code_block)
      result = H.sh! "mmdc -i omd.mmd -o mermaid.png"
      writer.image "mermaid.png", alt: "mermaid"
    end

    def bash(filters, code_block, writer:)
      tmp_file = ".omd-#{$$}.sh"
      File.write tmp_file, <<~BASH, permissions: 0755
      #!/bin/bash
      set -eu -o pipefail
      #{code_block}
      BASH

      result = H.sh! "./#{tmp_file}"
      if filters.length == 1
        writer.code_block result, lang: filters.first
      else
        writer.code_block result
      end
    ensure
      FileUtils.rm_f tmp_file
    end

    def cc(filters, code_block, writer:)
      H.which! "cc"

      File.write("omd.cc", code_block)

      H.sh! "cc -Wall omd.cc"

      result = H.sh! "./a.out"
      writer.code_block result
    end

    def sql(filters, code_block, writer:)
      H.which! "sqlite3", "brew install sqlite3"

      File.write("omd.sql", code_block)
      success = H.sh! "sqlite3 -noheader -separator $'\t' < omd.sql"
      writer.table(success, separator: "\t")
    end
  end

  def print_code_block(omd_args, code_block, writer:)
    return if omd_args =~ /^@/
    return if omd_args =~ /^comment/

    lang = $1 if omd_args =~ /^@?(\S+)/

    # lines starting with "@" will be hidden.
    code_block = code_block.gsub(/^@[^\n]*\n/, "")

    # remove leading and trailing empty lines.
    while code_block.start_with?("\n")
      code_block = code_block[1..-1]
    end
    while code_block.end_with?("\n")
      code_block = code_block[0...-1]
    end

    writer.code_block(code_block, lang: lang)
  end

  def process_in_dir(tmpdir:)
    return yield unless tmpdir

    Dir.mktmpdir do |tmpdir|
      Dir.chdir tmpdir do
        yield
      end
    end
  end

  # most languages are running inside a temp dir. bash isn't -
  # because we assume that a bash script might want to access
  # some local resources.
  unless defined?(LANGS_NOT_RUNNING_IN_TMP_DIR)
    LANGS_NOT_RUNNING_IN_TMP_DIR = %w(bash)
  end

  def process_code_block(file_reader, intro, code_block, writer:)
    intro.gsub!(/^@\s*/, "")
    lang, *filters = intro.split(/\s*\|\s*/)

    if !lang || !Processors.respond_to?(lang)
      writer.error "#{file_reader.location}: Unsupported omd processor #{lang.inspect}"
      return
    end

    logger.warn "#{file_reader.location}: processing #{intro.inspect} block"

    # Some commands are running inside a temp dir.
    run_in_tmp_dir = !LANGS_NOT_RUNNING_IN_TMP_DIR.include?(lang)

    process_in_dir(tmpdir: run_in_tmp_dir) do
      code_block = code_block.gsub(/^@\s*/, "")
      Processors.send lang, filters, code_block, writer: writer
    end
  end
end

unless $loaded
  $loaded = true
  Simple::CLI.run!(OMD::CLI) #, *ARGV)
end
